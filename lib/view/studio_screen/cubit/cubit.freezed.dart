// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$StudioState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() needLogIn,
    required TResult Function(List<AssetEntity> showcase) studio,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? needLogIn,
    TResult? Function(List<AssetEntity> showcase)? studio,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? needLogIn,
    TResult Function(List<AssetEntity> showcase)? studio,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StudioLoadingState value) loading,
    required TResult Function(_StudioNeedLogInState value) needLogIn,
    required TResult Function(_StudioState value) studio,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StudioLoadingState value)? loading,
    TResult? Function(_StudioNeedLogInState value)? needLogIn,
    TResult? Function(_StudioState value)? studio,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StudioLoadingState value)? loading,
    TResult Function(_StudioNeedLogInState value)? needLogIn,
    TResult Function(_StudioState value)? studio,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StudioStateCopyWith<$Res> {
  factory $StudioStateCopyWith(
          StudioState value, $Res Function(StudioState) then) =
      _$StudioStateCopyWithImpl<$Res, StudioState>;
}

/// @nodoc
class _$StudioStateCopyWithImpl<$Res, $Val extends StudioState>
    implements $StudioStateCopyWith<$Res> {
  _$StudioStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_StudioLoadingStateCopyWith<$Res> {
  factory _$$_StudioLoadingStateCopyWith(_$_StudioLoadingState value,
          $Res Function(_$_StudioLoadingState) then) =
      __$$_StudioLoadingStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StudioLoadingStateCopyWithImpl<$Res>
    extends _$StudioStateCopyWithImpl<$Res, _$_StudioLoadingState>
    implements _$$_StudioLoadingStateCopyWith<$Res> {
  __$$_StudioLoadingStateCopyWithImpl(
      _$_StudioLoadingState _value, $Res Function(_$_StudioLoadingState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_StudioLoadingState implements _StudioLoadingState {
  const _$_StudioLoadingState();

  @override
  String toString() {
    return 'StudioState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_StudioLoadingState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() needLogIn,
    required TResult Function(List<AssetEntity> showcase) studio,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? needLogIn,
    TResult? Function(List<AssetEntity> showcase)? studio,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? needLogIn,
    TResult Function(List<AssetEntity> showcase)? studio,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StudioLoadingState value) loading,
    required TResult Function(_StudioNeedLogInState value) needLogIn,
    required TResult Function(_StudioState value) studio,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StudioLoadingState value)? loading,
    TResult? Function(_StudioNeedLogInState value)? needLogIn,
    TResult? Function(_StudioState value)? studio,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StudioLoadingState value)? loading,
    TResult Function(_StudioNeedLogInState value)? needLogIn,
    TResult Function(_StudioState value)? studio,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _StudioLoadingState implements StudioState {
  const factory _StudioLoadingState() = _$_StudioLoadingState;
}

/// @nodoc
abstract class _$$_StudioNeedLogInStateCopyWith<$Res> {
  factory _$$_StudioNeedLogInStateCopyWith(_$_StudioNeedLogInState value,
          $Res Function(_$_StudioNeedLogInState) then) =
      __$$_StudioNeedLogInStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StudioNeedLogInStateCopyWithImpl<$Res>
    extends _$StudioStateCopyWithImpl<$Res, _$_StudioNeedLogInState>
    implements _$$_StudioNeedLogInStateCopyWith<$Res> {
  __$$_StudioNeedLogInStateCopyWithImpl(_$_StudioNeedLogInState _value,
      $Res Function(_$_StudioNeedLogInState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_StudioNeedLogInState implements _StudioNeedLogInState {
  const _$_StudioNeedLogInState();

  @override
  String toString() {
    return 'StudioState.needLogIn()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_StudioNeedLogInState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() needLogIn,
    required TResult Function(List<AssetEntity> showcase) studio,
  }) {
    return needLogIn();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? needLogIn,
    TResult? Function(List<AssetEntity> showcase)? studio,
  }) {
    return needLogIn?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? needLogIn,
    TResult Function(List<AssetEntity> showcase)? studio,
    required TResult orElse(),
  }) {
    if (needLogIn != null) {
      return needLogIn();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StudioLoadingState value) loading,
    required TResult Function(_StudioNeedLogInState value) needLogIn,
    required TResult Function(_StudioState value) studio,
  }) {
    return needLogIn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StudioLoadingState value)? loading,
    TResult? Function(_StudioNeedLogInState value)? needLogIn,
    TResult? Function(_StudioState value)? studio,
  }) {
    return needLogIn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StudioLoadingState value)? loading,
    TResult Function(_StudioNeedLogInState value)? needLogIn,
    TResult Function(_StudioState value)? studio,
    required TResult orElse(),
  }) {
    if (needLogIn != null) {
      return needLogIn(this);
    }
    return orElse();
  }
}

abstract class _StudioNeedLogInState implements StudioState {
  const factory _StudioNeedLogInState() = _$_StudioNeedLogInState;
}

/// @nodoc
abstract class _$$_StudioStateCopyWith<$Res> {
  factory _$$_StudioStateCopyWith(
          _$_StudioState value, $Res Function(_$_StudioState) then) =
      __$$_StudioStateCopyWithImpl<$Res>;
  @useResult
  $Res call({List<AssetEntity> showcase});
}

/// @nodoc
class __$$_StudioStateCopyWithImpl<$Res>
    extends _$StudioStateCopyWithImpl<$Res, _$_StudioState>
    implements _$$_StudioStateCopyWith<$Res> {
  __$$_StudioStateCopyWithImpl(
      _$_StudioState _value, $Res Function(_$_StudioState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? showcase = null,
  }) {
    return _then(_$_StudioState(
      showcase: null == showcase
          ? _value._showcase
          : showcase // ignore: cast_nullable_to_non_nullable
              as List<AssetEntity>,
    ));
  }
}

/// @nodoc

class _$_StudioState implements _StudioState {
  const _$_StudioState({required final List<AssetEntity> showcase})
      : _showcase = showcase;

  final List<AssetEntity> _showcase;
  @override
  List<AssetEntity> get showcase {
    if (_showcase is EqualUnmodifiableListView) return _showcase;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_showcase);
  }

  @override
  String toString() {
    return 'StudioState.studio(showcase: $showcase)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StudioState &&
            const DeepCollectionEquality().equals(other._showcase, _showcase));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_showcase));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StudioStateCopyWith<_$_StudioState> get copyWith =>
      __$$_StudioStateCopyWithImpl<_$_StudioState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() needLogIn,
    required TResult Function(List<AssetEntity> showcase) studio,
  }) {
    return studio(showcase);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function()? needLogIn,
    TResult? Function(List<AssetEntity> showcase)? studio,
  }) {
    return studio?.call(showcase);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? needLogIn,
    TResult Function(List<AssetEntity> showcase)? studio,
    required TResult orElse(),
  }) {
    if (studio != null) {
      return studio(showcase);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StudioLoadingState value) loading,
    required TResult Function(_StudioNeedLogInState value) needLogIn,
    required TResult Function(_StudioState value) studio,
  }) {
    return studio(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StudioLoadingState value)? loading,
    TResult? Function(_StudioNeedLogInState value)? needLogIn,
    TResult? Function(_StudioState value)? studio,
  }) {
    return studio?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StudioLoadingState value)? loading,
    TResult Function(_StudioNeedLogInState value)? needLogIn,
    TResult Function(_StudioState value)? studio,
    required TResult orElse(),
  }) {
    if (studio != null) {
      return studio(this);
    }
    return orElse();
  }
}

abstract class _StudioState implements StudioState {
  const factory _StudioState({required final List<AssetEntity> showcase}) =
      _$_StudioState;

  List<AssetEntity> get showcase;
  @JsonKey(ignore: true)
  _$$_StudioStateCopyWith<_$_StudioState> get copyWith =>
      throw _privateConstructorUsedError;
}
